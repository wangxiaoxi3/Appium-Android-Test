{
  "uid" : "c44058ea65273685",
  "name" : "test_discover.TestDiscover.test_play_genres_album",
  "title" : "Test play genres album",
  "time" : {
    "start" : 1544066802797,
    "stop" : 1544066814195,
    "duration" : 11398
  },
  "summary" : {
    "attachments" : 0,
    "steps" : 0
  },
  "failure" : {
    "message" : "URLError: <urlopen error [Errno 61] Connection refused>",
    "stackTrace" : "self = <urllib.request.HTTPHandler object at 0x10f2db710>\nhttp_class = <class 'http.client.HTTPConnection'>\nreq = <selenium.webdriver.remote.remote_connection.Request object at 0x10f2dba90>\nhttp_conn_args = {}, host = 'localhost:4724'\nh = <http.client.HTTPConnection object at 0x10f2db160>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n>               h.request(req.get_method(), req.selector, req.data, headers)\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py:1240: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10f2db160>, method = 'POST'\nurl = '/wd/hub/session'\nbody = b'{\"desiredCapabilities\": {\"newCommandTimeout\": \"2000\", \"appPackage\": \"com.papayamobile.fm.pre\", \"platformName\": \"Andr...\", \"resetKeyboard\": true, \"appActivity\": \"com.papayamobile.fm.activities.SplashActivity\"}, \"requiredCapabilities\": {}}'\nheaders = {'Accept': 'application/json', 'Connection': 'close', 'Content-Length': '469', 'Content-Type': 'application/json;charset=UTF-8', ...}\n\n    def request(self, method, url, body=None, headers={}):\n        \"\"\"Send a complete request to the server.\"\"\"\n>       self._send_request(method, url, body, headers)\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/http/client.py:1083: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10f2db160>, method = 'POST'\nurl = '/wd/hub/session'\nbody = b'{\"desiredCapabilities\": {\"newCommandTimeout\": \"2000\", \"appPackage\": \"com.papayamobile.fm.pre\", \"platformName\": \"Andr...\", \"resetKeyboard\": true, \"appActivity\": \"com.papayamobile.fm.activities.SplashActivity\"}, \"requiredCapabilities\": {}}'\nheaders = {'Accept': 'application/json', 'Connection': 'close', 'Content-Length': '469', 'Content-Type': 'application/json;charset=UTF-8', ...}\n\n    def _send_request(self, method, url, body, headers):\n        # Honor explicitly requested Host: and Accept-Encoding: headers.\n        header_names = dict.fromkeys([k.lower() for k in headers])\n        skips = {}\n        if 'host' in header_names:\n            skips['skip_host'] = 1\n        if 'accept-encoding' in header_names:\n            skips['skip_accept_encoding'] = 1\n    \n        self.putrequest(method, url, **skips)\n    \n        if 'content-length' not in header_names:\n            self._set_content_length(body, method)\n        for hdr, value in headers.items():\n            self.putheader(hdr, value)\n        if isinstance(body, str):\n            # RFC 2616 Section 3.7.1 says that text default has a\n            # default charset of iso-8859-1.\n            body = body.encode('iso-8859-1')\n>       self.endheaders(body)\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/http/client.py:1128: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10f2db160>\nmessage_body = b'{\"desiredCapabilities\": {\"newCommandTimeout\": \"2000\", \"appPackage\": \"com.papayamobile.fm.pre\", \"platformName\": \"Andr...\", \"resetKeyboard\": true, \"appActivity\": \"com.papayamobile.fm.activities.SplashActivity\"}, \"requiredCapabilities\": {}}'\n\n    def endheaders(self, message_body=None):\n        \"\"\"Indicate that the last header line has been sent to the server.\n    \n        This method sends the request to the server.  The optional message_body\n        argument can be used to pass a message body associated with the\n        request.  The message body will be sent in the same packet as the\n        message headers if it is a string, otherwise it is sent as a separate\n        packet.\n        \"\"\"\n        if self.__state == _CS_REQ_STARTED:\n            self.__state = _CS_REQ_SENT\n        else:\n            raise CannotSendHeader()\n>       self._send_output(message_body)\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/http/client.py:1079: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10f2db160>\nmessage_body = b'{\"desiredCapabilities\": {\"newCommandTimeout\": \"2000\", \"appPackage\": \"com.papayamobile.fm.pre\", \"platformName\": \"Andr...\", \"resetKeyboard\": true, \"appActivity\": \"com.papayamobile.fm.activities.SplashActivity\"}, \"requiredCapabilities\": {}}'\n\n    def _send_output(self, message_body=None):\n        \"\"\"Send the currently buffered request and clear the buffer.\n    \n        Appends an extra \\\\r\\\\n to the buffer.\n        A message_body may be specified, to be appended to the request.\n        \"\"\"\n        self._buffer.extend((b\"\", b\"\"))\n        msg = b\"\\r\\n\".join(self._buffer)\n        del self._buffer[:]\n    \n>       self.send(msg)\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/http/client.py:911: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10f2db160>\ndata = b'POST /wd/hub/session HTTP/1.1\\r\\nAccept-Encoding: identity\\r\\nConnection: close\\r\\nUser-Agent: Python-urllib/3.5\\r\\n...alhost:4724\\r\\nAccept: application/json\\r\\nContent-Type: application/json;charset=UTF-8\\r\\nContent-Length: 469\\r\\n\\r\\n'\n\n    def send(self, data):\n        \"\"\"Send `data' to the server.\n        ``data`` can be a string object, a bytes object, an array object, a\n        file-like object that supports a .read() method, or an iterable object.\n        \"\"\"\n    \n        if self.sock is None:\n            if self.auto_open:\n>               self.connect()\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/http/client.py:854: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <http.client.HTTPConnection object at 0x10f2db160>\n\n    def connect(self):\n        \"\"\"Connect to the host and port specified in __init__.\"\"\"\n        self.sock = self._create_connection(\n>           (self.host,self.port), self.timeout, self.source_address)\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/http/client.py:826: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('localhost', 4724), timeout = <object object at 0x101e82170>\nsource_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n                sock.connect(sa)\n                return sock\n    \n            except error as _:\n                err = _\n                if sock is not None:\n                    sock.close()\n    \n        if err is not None:\n>           raise err\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/socket.py:707: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\naddress = ('localhost', 4724), timeout = <object object at 0x101e82170>\nsource_address = None\n\n    def create_connection(address, timeout=_GLOBAL_DEFAULT_TIMEOUT,\n                          source_address=None):\n        \"\"\"Connect to *address* and return the socket object.\n    \n        Convenience function.  Connect to *address* (a 2-tuple ``(host,\n        port)``) and return the socket object.  Passing the optional\n        *timeout* parameter will set the timeout on the socket instance\n        before attempting to connect.  If no *timeout* is supplied, the\n        global default timeout setting returned by :func:`getdefaulttimeout`\n        is used.  If *source_address* is set it must be a tuple of (host, port)\n        for the socket to bind as a source address before making the connection.\n        An host of '' or port 0 tells the OS to use the default.\n        \"\"\"\n    \n        host, port = address\n        err = None\n        for res in getaddrinfo(host, port, 0, SOCK_STREAM):\n            af, socktype, proto, canonname, sa = res\n            sock = None\n            try:\n                sock = socket(af, socktype, proto)\n                if timeout is not _GLOBAL_DEFAULT_TIMEOUT:\n                    sock.settimeout(timeout)\n                if source_address:\n                    sock.bind(source_address)\n>               sock.connect(sa)\nE               ConnectionRefusedError: [Errno 61] Connection refused\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/socket.py:698: ConnectionRefusedError\n\nDuring handling of the above exception, another exception occurred:\n\n    @pytest.fixture()\n    def action():\n        env = Environment().get_environment_info()\n    \n        allure.environment(app=env.apk)\n        allure.environment(app_activity=env.app_activity)\n        allure.environment(device_name=env.devices[0].device_name)\n        allure.environment(platform_name=env.devices[0].platform_name)\n        allure.environment(platform_version=env.devices[0].platform_version)\n    \n        capabilities = {'platformName': env.devices[0].platform_name,\n                        'platformVersion': env.devices[0].platform_version,\n                        'deviceName': env.devices[0].device_name,\n                        'app': env.apk,\n                        'clearSystemFiles': True,\n                        'appActivity': env.app_activity,\n                        'appPackage': env.app_package,\n                        'automationName': 'UIAutomator2',\n                        'newCommandTimeout': \"2000\",\n                        'unicodeKeyboard': True,\n                        'resetKeyboard': True,\n                        'noSign': True\n                        }\n        host = \"http://localhost:4724/wd/hub\"\n>       driver = webdriver.Remote(host, capabilities)\n\ntest/conftest.py:40: \n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/appium/webdriver/webdriver.py:36: in __init__\n    super(WebDriver, self).__init__(command_executor, desired_capabilities, browser_profile, proxy, keep_alive)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/selenium/webdriver/remote/webdriver.py:90: in __init__\n    self.start_session(desired_capabilities, browser_profile)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/selenium/webdriver/remote/webdriver.py:177: in start_session\n    response = self.execute(Command.NEW_SESSION, capabilities)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/selenium/webdriver/remote/webdriver.py:234: in execute\n    response = self.command_executor.execute(driver_command, params)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/selenium/webdriver/remote/remote_connection.py:401: in execute\n    return self._request(command_info[0], url, body=data)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/site-packages/selenium/webdriver/remote/remote_connection.py:471: in _request\n    resp = opener.open(request, timeout=self._timeout)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py:465: in open\n    response = self._open(req, data)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py:483: in _open\n    '_open', req)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py:443: in _call_chain\n    result = func(*args)\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py:1268: in http_open\n    return self.do_open(http.client.HTTPConnection, req)\n_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ \n\nself = <urllib.request.HTTPHandler object at 0x10f2db710>\nhttp_class = <class 'http.client.HTTPConnection'>\nreq = <selenium.webdriver.remote.remote_connection.Request object at 0x10f2dba90>\nhttp_conn_args = {}, host = 'localhost:4724'\nh = <http.client.HTTPConnection object at 0x10f2db160>\n\n    def do_open(self, http_class, req, **http_conn_args):\n        \"\"\"Return an HTTPResponse object for the request, using http_class.\n    \n        http_class must implement the HTTPConnection API from http.client.\n        \"\"\"\n        host = req.host\n        if not host:\n            raise URLError('no host given')\n    \n        # will parse host:port\n        h = http_class(host, timeout=req.timeout, **http_conn_args)\n    \n        headers = dict(req.unredirected_hdrs)\n        headers.update(dict((k, v) for k, v in req.headers.items()\n                            if k not in headers))\n    \n        # TODO(jhylton): Should this be redesigned to handle\n        # persistent connections?\n    \n        # We want to make an HTTP/1.1 request, but the addinfourl\n        # class isn't prepared to deal with a persistent connection.\n        # It will try to read all remaining data from the socket,\n        # which will block while the server waits for the next request.\n        # So make sure the connection gets closed after the (only)\n        # request.\n        headers[\"Connection\"] = \"close\"\n        headers = dict((name.title(), val) for name, val in headers.items())\n    \n        if req._tunnel_host:\n            tunnel_headers = {}\n            proxy_auth_hdr = \"Proxy-Authorization\"\n            if proxy_auth_hdr in headers:\n                tunnel_headers[proxy_auth_hdr] = headers[proxy_auth_hdr]\n                # Proxy-Authorization should not be sent to origin\n                # server.\n                del headers[proxy_auth_hdr]\n            h.set_tunnel(req._tunnel_host, headers=tunnel_headers)\n    \n        try:\n            try:\n                h.request(req.get_method(), req.selector, req.data, headers)\n            except OSError as err: # timeout error\n>               raise URLError(err)\nE               urllib.error.URLError: <urlopen error [Errno 61] Connection refused>\n\n/Library/Frameworks/Python.framework/Versions/3.5/lib/python3.5/urllib/request.py:1242: URLError"
  },
  "description" : {
    "value" : "\n        验证genres内专辑可播放\n\n        ",
    "type" : "TEXT"
  },
  "severity" : "NORMAL",
  "status" : "BROKEN",
  "testId" : null,
  "suite" : {
    "uid" : "90410f17963a2624",
    "name" : "test",
    "title" : "Test"
  },
  "steps" : [ ],
  "attachments" : [ ],
  "issues" : [ ],
  "labels" : [ {
    "name" : "thread",
    "value" : "92305-MainThread"
  }, {
    "name" : "suite-name",
    "value" : "test"
  }, {
    "name" : "framework",
    "value" : "pytest"
  }, {
    "name" : "suite-title",
    "value" : null
  }, {
    "name" : "severity",
    "value" : "normal"
  }, {
    "name" : "host",
    "value" : "xiaoxideMacBook-Pro.local"
  }, {
    "name" : "story",
    "value" : "genres"
  }, {
    "name" : "language",
    "value" : "cpython3"
  }, {
    "name" : "feature",
    "value" : "Home1"
  } ],
  "parameters" : [ ]
}